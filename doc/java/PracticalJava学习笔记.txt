1. 参数以by value方式而非by reference 方式传递    cloning(克隆)	immutable(不可变的)	2. 对不变的data和object references使用final    final int 	final Object	3. 缺省情况下所有non-static函数都可被覆写    final class	final method()	4. 在arrays和Vectors之间慎重选择    缺省赋值：	    boolean           false		char              '\u0000'		byte              0		short             0		int               0		long              0		float             0.0		double            0.0		object reference  null	array：固定大小，支持基本类型，速度快	Vector：可变大小，不支持基本类型，速度慢	5. 多态(polymorphism)优于instanceof		6. 必要时才使用instanceof    向上转型：List list = new ArrayList()    向下转型：List list = (List) object	    ClassCastException -> instanceof		7. 一旦不再需要object references，就将它设为null    Java垃圾回收机制	局部变量：方法调用结束，自动设为null	实例变量：对象生命期内释放，手动设为null	集合内的变量：集合生命期内释放，手动设为null	大对象：尽早释放	完整生命期内的对象：尽早释放	8. 区别reference型别和primitive型别    primitive型别      reference型别	boolean            Boolean	char               Character	byte               Byte	short              Short	int                Integer	long               Long	float              Float	double             Double	primitive型别：栈中存储数据	reference型别：栈中存储引用，堆中存储数据	9. 区分==和equals()    primitive型别比较：==比较值是否相等	reference型别比较：==比较对象引用是否相同	10. 不要依赖equals()的缺省实现    重写equals()方法	    类、子类 、外覆类11. 实现equals()时必须深思熟虑12. 实现equals()时优先考虑使用getClass()        先比较对象的类类型，必须是同一个类类型13. 调用super.equals()以唤起base class的相关行为14. 在equals()函数中谨慎使用instanceof    父类和子类比较	    父类：instanceof		子类：super.equals()15. 实现equals()时需遵循某些规则    两个对象可被视为逻辑上相等时，提供equals()	检查是否等于this	比较两个对象的相关属性	base class实现了equals()，调用super.equals()	只允许同一个class的对象相等时，使用getClass()	和base class进行比较的场合，才使用instanceof	16. 认识异常控制流(exception control flow)机制    try-catch-finally	17. 绝对不可轻忽异常    Java产生异常的处理方法：	    1) 捕捉，处理		2) 捕捉，再次抛出		3) 捕捉，抛出新的异常		4) 不捕捉，向外抛出18. 不要掩盖异常19.  20. 21. 22.23.24.25.26.27.28. 先把焦点放在设计、数据结构和算法身上    1) 良好的设计	2) 明智地选择数据结构	3) 明智地选择算法	29. 不要依赖编译器优化技术30. 理解运行期代码优化技术31. 字符串拼接，StringBuffer优于String32. 将对象的创建成本降至最小	1) 延迟创建	2) 对象设计	33. 不要创建不必要的对象34. 慎用synchronized35. 尽可能使用Stack变量36. 使用static, final, private函数以促成inline37. instance变量的初始化一次就好38. 尽量使用基本数据类型39. 尽量不要使用Enumeration或Iterator来遍历Vector40. 使用System.arraycopy来复制数组41. 优先使用数组，然后才考虑Vector和ArrayList42. 尽可能复用对象43. 延迟求值44. 手工方式优化代码	javac Test.java	javap -c Test > Test.bc	45. 编译为本机代码