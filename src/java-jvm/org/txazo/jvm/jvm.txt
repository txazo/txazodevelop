


1. .java源代码 - 编译器 - .class字节码 - jvm - 机器码 - 执行

1. 方法解析
1) 静态绑定
static、final、private、构造方法、父类方法
2) 动态绑定
在运行时根据具体对象的类型进行绑定

加载
1) 通过一个类的全限定名来获取其定义的二进制字节流(来源: jar包、class文件、网络)
2) 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3) 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口

类加载
对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在就Java虚拟机中的唯一性
1) Bootstrap ClassLoader
2) Extension ClassLoader
3) System ClassLoader
4) Custom ClassLoader

双亲委派模型

Java绑定
1) 静态绑定: 编译期绑定
	static、final、private、构造方法、父类方法
2) 动态绑定: 运行时绑定

验证
确保Class文件中的字节流包含的信息符合当前虚拟机的要求
1) 文件格式的验证
2) 元数据验证
3) 字节码验证
4) 符号引用验证

准备
为static类变量分配内存并设置类变量初始值(默认值)的阶段，这些内存都将在方法区中分配
初始化static final变量的值

解析
将常量池中的符号引用转化为直接引用的过程
解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行

初始化
类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码
初始化阶段是执行类构造器<clinit>()方法的过程
<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的
编译器收集的顺序是由语句在源文件中出现的顺序所决定的
接口中不能使用静态语句块, 但仍然有类变量(final static)初始化的赋值操作, 接口与类一样会生成<clinit>()方法
执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法
只有当父接口中定义的变量被使用时，父接口才会被初始化
接口的实现类在初始化时也一样不会执行接口的<clinit>()方法

方法解析
一切方法调用在Class文件里面存储的都只是符号引用, 而不是方法在实际运行时内存布局中的入口地址
1) 静态解析: 编译器可知，运行期不可变, 符号引用转化为直接引用
   非虚方法: static final private 构造方法 父类方法
2) 动态连接

静态分派
Javac编译器就根据参数的静态类型决定使用哪个重载版本
动态分派
在运行期根据实际类型确定方法执行版本

方法的调用者与方法的参数统称为方法的宗量
单分派: 根据一个宗量对目标方法进行选择
多分派: 根据多于一个宗量对目标方法进行选择

静态分派属于多分派类型, 方法重载
动态分派属于单分派类型, 方法覆写

语法糖
泛型、变长参数、条件编译、自动拆装箱、内部类
虚拟机并不支持这些语法, 它们在编译阶段就被还原回了简单的基础语法结构, 这个过程成为解语法糖

Java语言中的泛型实现方法称为类型擦除, 基于这种方法实现的泛型被称为伪泛型
Java代码中的方法特征签名只包括了方法名称、参数顺序和参数类型, 并不包括方法的返回值

Javac编译
1) 字节码生成
	实例构造器<init>()
	类构造器<clinit>()

JIT编译
热点代码: 虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化
运行过程中会被即时编译器编译的热点代码有两类: 被多次调用的方法 被多次调用的循环体

对象引用
1) 强引用
2) 软引用
3) 弱引用
4) 虚引用

垃圾标记算法
1) 引用计数算法
2) 根搜索算法

垃圾收集算法
1) 标记—清除算法
2) 复制算法
3) 标记—整理算法
4) 分代收集

垃圾收集器

垃圾回收分析
1) 对象优先在Eden分配
2) 大对象直接进入老年代
3) 长期存活的对象将进入老年代

新生代GC, Minor GC, 发生在新生代的垃圾收集动作
Minor GC非常频繁，一般回收速度也比较快

老年代GC, Full GC, 发生在老年代的GC，出现了Full GC，经常会伴随至少一次Minor GC
由于老年代中的对象生命周期比较长，因此Full GC并不频繁，一般都是等待老年代满了后才进行Full GC

性能调优